<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="imu__sensor__model_8cpp" kind="file" language="C++">
    <compoundname>imu_sensor_model.cpp</compoundname>
    <includes refid="imu__sensor__model_8hpp" local="yes">kinematic_arbiter/sensors/imu_sensor_model.hpp</includes>
    <includes refid="state__index_8hpp" local="yes">kinematic_arbiter/core/state_index.hpp</includes>
    <includes refid="statistical__utils_8hpp" local="yes">kinematic_arbiter/core/statistical_utils.hpp</includes>
    <includes local="no">Eigen/Geometry</includes>
    <includes local="no">cmath</includes>
    <incdepgraph>
      <node id="9">
        <label>kinematic_arbiter/core/state_index.hpp</label>
        <link refid="state__index_8hpp"/>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
      </node>
      <node id="18">
        <label>limits</label>
      </node>
      <node id="14">
        <label>kinematic_arbiter/core/mediation_types.hpp</label>
        <link refid="mediation__types_8hpp"/>
      </node>
      <node id="4">
        <label>Eigen/Geometry</label>
      </node>
      <node id="17">
        <label>cmath</label>
      </node>
      <node id="8">
        <label>stdexcept</label>
      </node>
      <node id="3">
        <label>Eigen/Core</label>
      </node>
      <node id="12">
        <label>string</label>
      </node>
      <node id="2">
        <label>kinematic_arbiter/sensors/imu_sensor_model.hpp</label>
        <link refid="imu__sensor__model_8hpp"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="21" relation="include">
        </childnode>
        <childnode refid="20" relation="include">
        </childnode>
      </node>
      <node id="19">
        <label>random</label>
      </node>
      <node id="6">
        <label>Eigen/Dense</label>
      </node>
      <node id="5">
        <label>kinematic_arbiter/core/measurement_model_interface.hpp</label>
        <link refid="measurement__model__interface_8hpp"/>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="14" relation="include">
        </childnode>
        <childnode refid="15" relation="include">
        </childnode>
        <childnode refid="20" relation="include">
        </childnode>
      </node>
      <node id="21">
        <label>kinematic_arbiter/sensors/imu_bias_estimator.hpp</label>
        <link refid="imu__bias__estimator_8hpp"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
      </node>
      <node id="11">
        <label>vector</label>
      </node>
      <node id="20">
        <label>kinematic_arbiter/core/sensor_types.hpp</label>
        <link refid="sensor__types_8hpp"/>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
      </node>
      <node id="15">
        <label>kinematic_arbiter/core/statistical_utils.hpp</label>
        <link refid="statistical__utils_8hpp"/>
        <childnode refid="16" relation="include">
        </childnode>
        <childnode refid="17" relation="include">
        </childnode>
        <childnode refid="18" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="19" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
      </node>
      <node id="1">
        <label>/home/spencer/ros2workspace/src/kinematic_arbiter/src/sensors/imu_sensor_model.cpp</label>
        <link refid="imu__sensor__model_8cpp"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="15" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="17" relation="include">
        </childnode>
      </node>
      <node id="16">
        <label>array</label>
      </node>
      <node id="7">
        <label>iostream</label>
      </node>
      <node id="10">
        <label>cstddef</label>
      </node>
      <node id="13">
        <label>unordered_map</label>
      </node>
    </incdepgraph>
    <innernamespace refid="namespacekinematic__arbiter">kinematic_arbiter</innernamespace>
    <innernamespace refid="namespacekinematic__arbiter_1_1sensors">kinematic_arbiter::sensors</innernamespace>
    <innernamespace refid="namespaceEigen">Eigen</innernamespace>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="preprocessor">#include<sp/>&quot;<ref refid="imu__sensor__model_8hpp" kindref="compound">kinematic_arbiter/sensors/imu_sensor_model.hpp</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="state__index_8hpp" kindref="compound">kinematic_arbiter/core/state_index.hpp</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="statistical__utils_8hpp" kindref="compound">kinematic_arbiter/core/statistical_utils.hpp</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;Eigen/Geometry&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cmath&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal"><ref refid="namespacekinematic__arbiter" kindref="compound">kinematic_arbiter</ref><sp/>{</highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">sensors<sp/>{</highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight></codeline>
<codeline lineno="10"><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>core::StateIndex;</highlight></codeline>
<codeline lineno="11"><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal">Eigen;</highlight></codeline>
<codeline lineno="12"><highlight class="normal"></highlight></codeline>
<codeline lineno="13"><highlight class="normal"></highlight><highlight class="comment">//<sp/>namespace<sp/>{</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14"><highlight class="normal"></highlight></codeline>
<codeline lineno="15"><highlight class="normal"></highlight><highlight class="comment">//<sp/>constexpr<sp/>double<sp/>kGravity<sp/>=<sp/>9.80665;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16" refid="namespacekinematic__arbiter_1_1sensors_1a687fad93ff58abc219b838b61df405cb" refkind="member"><highlight class="normal">constexpr<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/><ref refid="namespacekinematic__arbiter_1_1sensors_1a687fad93ff58abc219b838b61df405cb" kindref="member">kEpsilon</ref><sp/>=<sp/>1e-6;</highlight></codeline>
<codeline lineno="17"><highlight class="normal"></highlight></codeline>
<codeline lineno="18"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Vector3d<sp/>QuaternionLog(const<sp/>Quaterniond&amp;<sp/>q)<sp/>{</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="19"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>w_clamped<sp/>=<sp/>std::clamp(q.w(),<sp/>-1.0<sp/>+<sp/>kEpsilon,<sp/>1.0<sp/>-<sp/>kEpsilon);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="20"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/>const<sp/>Vector3d<sp/>v<sp/>=<sp/>q.vec();</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="21"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>v_norm<sp/>=<sp/>v.norm();</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="22"><highlight class="normal"></highlight></codeline>
<codeline lineno="23"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/>if(v_norm<sp/>&lt;<sp/>kEpsilon)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="24"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>Vector3d::Zero();</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="25"><highlight class="normal"></highlight></codeline>
<codeline lineno="26"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>theta<sp/>=<sp/>2.0<sp/>*<sp/>std::acos(w_clamped);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="27"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/>return<sp/>theta<sp/>*<sp/>v.normalized();</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="28"><highlight class="normal"></highlight><highlight class="comment">//<sp/>}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="29"><highlight class="normal"></highlight></codeline>
<codeline lineno="30"><highlight class="normal"></highlight><highlight class="comment">//<sp/>}<sp/>//<sp/>namespace</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="31"><highlight class="normal"></highlight></codeline>
<codeline lineno="32" refid="classkinematic__arbiter_1_1sensors_1_1ImuSensorModel_1a8f33ace296557e492289729d1a378ac7" refkind="member"><highlight class="normal"><ref refid="classkinematic__arbiter_1_1core_1_1MeasurementModelInterface_1a9dfbdba5f6b255c3ac4c8ca73eb58a5b" kindref="member">ImuSensorModel::Base::DynamicVector</ref><sp/><ref refid="classkinematic__arbiter_1_1sensors_1_1ImuSensorModel_1a8f33ace296557e492289729d1a378ac7" kindref="member">ImuSensorModel::PredictMeasurement</ref>(</highlight></codeline>
<codeline lineno="33"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classkinematic__arbiter_1_1core_1_1MeasurementModelInterface_1abd357cd1e2aabe2107244532db30ece0" kindref="member">StateVector</ref>&amp;<sp/>state)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="34"><highlight class="normal"><sp/><sp/><ref refid="classkinematic__arbiter_1_1sensors_1_1ImuSensorModel_1a6c6ee31c6adbed7273d71e556662dabb" kindref="member">Vector</ref><sp/>predicted_measurement;</highlight></codeline>
<codeline lineno="35"><highlight class="normal"></highlight></codeline>
<codeline lineno="36"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Extract<sp/>state<sp/>components</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="37"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Eigen::Quaterniond<sp/>q(</highlight></codeline>
<codeline lineno="38"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>state(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1a974ce211cf31eba33fd4a89c0706432f" kindref="member">StateIndex::Quaternion::W</ref>),</highlight></codeline>
<codeline lineno="39"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>state(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1a16846a86810c4a3c7b1651bd10586cfe" kindref="member">StateIndex::Quaternion::X</ref>),</highlight></codeline>
<codeline lineno="40"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>state(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1af1d78b2f18147bf1abec5a47d984e63c" kindref="member">StateIndex::Quaternion::Y</ref>),</highlight></codeline>
<codeline lineno="41"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>state(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1a8a8ad785fbd7f06509eae6b27b7d20c9" kindref="member">StateIndex::Quaternion::Z</ref>)</highlight></codeline>
<codeline lineno="42"><highlight class="normal"><sp/><sp/>);</highlight></codeline>
<codeline lineno="43"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Eigen::Vector3d<sp/>omega<sp/>=<sp/>state.segment&lt;3&gt;(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1AngularVelocity_1ab5079ed794f17df901a6199dc51d9da8" kindref="member">StateIndex::AngularVelocity::X</ref>);</highlight></codeline>
<codeline lineno="44"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Eigen::Vector3d<sp/>a_linear<sp/>=<sp/>state.segment&lt;3&gt;(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1LinearAcceleration_1aec74bb1d8af0022628c73105f68ab432" kindref="member">StateIndex::LinearAcceleration::X</ref>);</highlight></codeline>
<codeline lineno="45"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Eigen::Vector3d<sp/>alpha<sp/>=<sp/>state.segment&lt;3&gt;(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1AngularAcceleration_1ad54f3ad255cbacc2ad29b7c97a3f1f5a" kindref="member">StateIndex::AngularAcceleration::X</ref>);</highlight></codeline>
<codeline lineno="46"><highlight class="normal"></highlight></codeline>
<codeline lineno="47"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Extract<sp/>sensor<sp/>configuration</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="48"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Eigen::Vector3d&amp;<sp/>r<sp/>=<sp/>sensor_pose_in_body_frame_.translation();</highlight></codeline>
<codeline lineno="49"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Eigen::Matrix3d&amp;<sp/>R_BS<sp/>=<sp/>sensor_pose_in_body_frame_.rotation().transpose();</highlight></codeline>
<codeline lineno="50"><highlight class="normal"></highlight></codeline>
<codeline lineno="51"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Gravity<sp/>vector<sp/>in<sp/>world<sp/>frame</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="52"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Eigen::Vector3d<sp/>g_W(0.0,<sp/>0.0,<sp/>kGravity);</highlight></codeline>
<codeline lineno="53"><highlight class="normal"></highlight></codeline>
<codeline lineno="54"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Base<sp/>gyroscope<sp/>measurement<sp/>without<sp/>bias</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="55"><highlight class="normal"><sp/><sp/>Eigen::Vector3d<sp/>gyro<sp/>=<sp/>R_BS<sp/>*<sp/>omega;</highlight></codeline>
<codeline lineno="56"><highlight class="normal"></highlight></codeline>
<codeline lineno="57"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Base<sp/>accelerometer<sp/>measurement<sp/>without<sp/>bias</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="58"><highlight class="normal"><sp/><sp/>Eigen::Vector3d<sp/>accel<sp/>=<sp/>R_BS<sp/>*<sp/>(</highlight></codeline>
<codeline lineno="59"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>a_linear<sp/>+</highlight></codeline>
<codeline lineno="60"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>q.inverse()<sp/>*<sp/>g_W<sp/>+</highlight></codeline>
<codeline lineno="61"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>alpha.cross(r)<sp/>+</highlight></codeline>
<codeline lineno="62"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>omega.cross(omega.cross(r))</highlight></codeline>
<codeline lineno="63"><highlight class="normal"><sp/><sp/>);</highlight></codeline>
<codeline lineno="64"><highlight class="normal"></highlight></codeline>
<codeline lineno="65"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Apply<sp/>biases<sp/>only<sp/>if<sp/>calibration<sp/>is<sp/>enabled</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="66"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(config_.calibration_enabled)<sp/>{</highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/><sp/><sp/>gyro<sp/>+=<sp/>bias_estimator_.GetGyroBias();</highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/><sp/><sp/>accel<sp/>+=<sp/>bias_estimator_.GetAccelBias();</highlight></codeline>
<codeline lineno="69"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="70"><highlight class="normal"></highlight></codeline>
<codeline lineno="71"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Set<sp/>the<sp/>measurement<sp/>components</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="72"><highlight class="normal"><sp/><sp/>predicted_measurement.segment&lt;3&gt;(MeasurementIndex::GX)<sp/>=<sp/>gyro;</highlight></codeline>
<codeline lineno="73"><highlight class="normal"><sp/><sp/>predicted_measurement.segment&lt;3&gt;(MeasurementIndex::AX)<sp/>=<sp/>accel;</highlight></codeline>
<codeline lineno="74"><highlight class="normal"></highlight></codeline>
<codeline lineno="75"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>predicted_measurement;</highlight></codeline>
<codeline lineno="76"><highlight class="normal">}</highlight></codeline>
<codeline lineno="77"><highlight class="normal"></highlight></codeline>
<codeline lineno="78" refid="classkinematic__arbiter_1_1sensors_1_1ImuSensorModel_1a1ba34a3a2ffd727fbf186816b108cd95" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/><ref refid="classkinematic__arbiter_1_1sensors_1_1ImuSensorModel_1a1ba34a3a2ffd727fbf186816b108cd95" kindref="member">ImuSensorModel::UpdateBiasEstimates</ref>(</highlight></codeline>
<codeline lineno="79"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classkinematic__arbiter_1_1core_1_1MeasurementModelInterface_1abd357cd1e2aabe2107244532db30ece0" kindref="member">StateVector</ref>&amp;<sp/>state,</highlight></codeline>
<codeline lineno="80"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Eigen::MatrixXd&amp;<sp/>state_covariance,</highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classkinematic__arbiter_1_1sensors_1_1ImuSensorModel_1a6c6ee31c6adbed7273d71e556662dabb" kindref="member">Vector</ref>&amp;<sp/>measurement)<sp/>{</highlight></codeline>
<codeline lineno="82"><highlight class="normal"></highlight></codeline>
<codeline lineno="83"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!config_.calibration_enabled<sp/>||<sp/>!IsStationary(state,<sp/>state_covariance,<sp/>measurement))<sp/>{</highlight></codeline>
<codeline lineno="84"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="85"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="86"><highlight class="normal"></highlight></codeline>
<codeline lineno="87"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>predicted<sp/>measurement</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="88"><highlight class="normal"><sp/><sp/><ref refid="classkinematic__arbiter_1_1sensors_1_1ImuSensorModel_1a6c6ee31c6adbed7273d71e556662dabb" kindref="member">Vector</ref><sp/>predicted_measurement<sp/>=<sp/>PredictMeasurement(state);</highlight></codeline>
<codeline lineno="89"><highlight class="normal"></highlight></codeline>
<codeline lineno="90"><highlight class="normal"></highlight></codeline>
<codeline lineno="91"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Update<sp/>bias<sp/>estimates</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="92"><highlight class="normal"><sp/><sp/>bias_estimator_.EstimateBiases(</highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>measurement.segment&lt;3&gt;(MeasurementIndex::GX),</highlight></codeline>
<codeline lineno="94"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>measurement.segment&lt;3&gt;(MeasurementIndex::AX),</highlight></codeline>
<codeline lineno="95"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>predicted_measurement.segment&lt;3&gt;(MeasurementIndex::GX),</highlight></codeline>
<codeline lineno="96"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>predicted_measurement.segment&lt;3&gt;(MeasurementIndex::AX));</highlight></codeline>
<codeline lineno="97"><highlight class="normal"></highlight></codeline>
<codeline lineno="98"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="99"><highlight class="normal">}</highlight></codeline>
<codeline lineno="100"><highlight class="normal"></highlight></codeline>
<codeline lineno="101" refid="classkinematic__arbiter_1_1sensors_1_1ImuSensorModel_1a5d8356e86f3e3dbcb810985a4debff1d" refkind="member"><highlight class="normal"><ref refid="classkinematic__arbiter_1_1core_1_1MeasurementModelInterface_1a72e3859677c567145f7abfddc1783368" kindref="member">ImuSensorModel::Base::DynamicJacobian</ref><sp/><ref refid="classkinematic__arbiter_1_1sensors_1_1ImuSensorModel_1a5d8356e86f3e3dbcb810985a4debff1d" kindref="member">ImuSensorModel::GetMeasurementJacobian</ref>(</highlight></codeline>
<codeline lineno="102"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classkinematic__arbiter_1_1core_1_1MeasurementModelInterface_1abd357cd1e2aabe2107244532db30ece0" kindref="member">StateVector</ref>&amp;<sp/>state)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/><ref refid="classkinematic__arbiter_1_1sensors_1_1ImuSensorModel_1a1b718824924fcdf179c102454684c76b" kindref="member">Jacobian</ref><sp/>jacobian<sp/>=<sp/>Jacobian::Zero();</highlight></codeline>
<codeline lineno="104"><highlight class="normal"></highlight></codeline>
<codeline lineno="105"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Extract<sp/>state<sp/>components<sp/>and<sp/>sensor<sp/>configuration</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="106"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Eigen::Vector3d&amp;<sp/>r<sp/>=<sp/>sensor_pose_in_body_frame_.translation();</highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Eigen::Matrix3d&amp;<sp/>R_BS<sp/>=<sp/>sensor_pose_in_body_frame_.rotation().transpose();</highlight></codeline>
<codeline lineno="108"><highlight class="normal"></highlight></codeline>
<codeline lineno="109"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Eigen::Vector3d<sp/>omega<sp/>=<sp/>state.segment&lt;3&gt;(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1AngularVelocity_1ab5079ed794f17df901a6199dc51d9da8" kindref="member">StateIndex::AngularVelocity::X</ref>);</highlight></codeline>
<codeline lineno="110"><highlight class="normal"></highlight></codeline>
<codeline lineno="111"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Extract<sp/>and<sp/>normalize<sp/>quaternion<sp/>orientation</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="112"><highlight class="normal"><sp/><sp/>Eigen::Quaterniond<sp/>q(</highlight></codeline>
<codeline lineno="113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>state(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1a974ce211cf31eba33fd4a89c0706432f" kindref="member">StateIndex::Quaternion::W</ref>),</highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>state(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1a16846a86810c4a3c7b1651bd10586cfe" kindref="member">StateIndex::Quaternion::X</ref>),</highlight></codeline>
<codeline lineno="115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>state(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1af1d78b2f18147bf1abec5a47d984e63c" kindref="member">StateIndex::Quaternion::Y</ref>),</highlight></codeline>
<codeline lineno="116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>state(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1a8a8ad785fbd7f06509eae6b27b7d20c9" kindref="member">StateIndex::Quaternion::Z</ref>)</highlight></codeline>
<codeline lineno="117"><highlight class="normal"><sp/><sp/>);</highlight></codeline>
<codeline lineno="118"><highlight class="normal"><sp/><sp/>q.normalize();</highlight></codeline>
<codeline lineno="119"><highlight class="normal"></highlight></codeline>
<codeline lineno="120"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Helper<sp/>function<sp/>to<sp/>create<sp/>a<sp/>skew-symmetric<sp/>matrix<sp/>for<sp/>cross<sp/>products</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="121"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>skew<sp/>=<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Eigen::Vector3d&amp;<sp/>v)<sp/>-&gt;<sp/>Eigen::Matrix3d<sp/>{</highlight></codeline>
<codeline lineno="122"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(Eigen::Matrix3d()<sp/>&lt;&lt;</highlight></codeline>
<codeline lineno="123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>-v.z(),<sp/>v.y(),</highlight></codeline>
<codeline lineno="124"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>v.z(),<sp/>0,<sp/>-v.x(),</highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-v.y(),<sp/>v.x(),<sp/>0).finished();</highlight></codeline>
<codeline lineno="126"><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline lineno="127"><highlight class="normal"></highlight></codeline>
<codeline lineno="128"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>====<sp/>LOWER<sp/>BLOCK:<sp/>GYROSCOPE<sp/>JACOBIAN<sp/>====</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="129"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Gyro<sp/>measurement<sp/>is<sp/>simply<sp/>body<sp/>angular<sp/>velocity<sp/>rotated<sp/>to<sp/>sensor<sp/>frame</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/>jacobian.block&lt;3,<sp/>3&gt;(MeasurementIndex::GX,<sp/><ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1AngularVelocity_1ab5079ed794f17df901a6199dc51d9da8" kindref="member">StateIndex::AngularVelocity::X</ref>)<sp/>=<sp/>R_BS;</highlight></codeline>
<codeline lineno="131"><highlight class="normal"></highlight></codeline>
<codeline lineno="132"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>====<sp/>UPPER<sp/>BLOCK:<sp/>ACCELEROMETER<sp/>JACOBIAN<sp/>====</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="133"><highlight class="normal"></highlight></codeline>
<codeline lineno="134"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>Linear<sp/>acceleration<sp/>direct<sp/>mapping</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="135"><highlight class="normal"><sp/><sp/>jacobian.block&lt;3,<sp/>3&gt;(MeasurementIndex::AX,<sp/><ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1LinearAcceleration_1aec74bb1d8af0022628c73105f68ab432" kindref="member">StateIndex::LinearAcceleration::X</ref>)<sp/>=<sp/>R_BS;</highlight></codeline>
<codeline lineno="136"><highlight class="normal"></highlight></codeline>
<codeline lineno="137"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>2.<sp/>Angular<sp/>acceleration<sp/>effect<sp/>(tangential<sp/>acceleration):<sp/>-R_{BS}[r]_\times</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="138"><highlight class="normal"><sp/><sp/>jacobian.block&lt;3,<sp/>3&gt;(MeasurementIndex::AX,<sp/><ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1AngularAcceleration_1ad54f3ad255cbacc2ad29b7c97a3f1f5a" kindref="member">StateIndex::AngularAcceleration::X</ref>)<sp/>=</highlight></codeline>
<codeline lineno="139"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>-R_BS<sp/>*<sp/>skew(r);</highlight></codeline>
<codeline lineno="140"><highlight class="normal"></highlight></codeline>
<codeline lineno="141"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>3.<sp/>Angular<sp/>velocity<sp/>effect<sp/>on<sp/>acceleration</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="142"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>To<sp/>fix<sp/>the<sp/>issues<sp/>with<sp/>the<sp/>angular<sp/>velocity<sp/>Jacobian,<sp/>we&apos;ll<sp/>use<sp/>the<sp/>expanded<sp/>cross<sp/>product<sp/>formula</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="143"><highlight class="normal"><sp/><sp/>Eigen::Matrix3d<sp/>omega_cross_r_jacobian<sp/>=<sp/>Eigen::Matrix3d::Zero();</highlight></codeline>
<codeline lineno="144"><highlight class="normal"></highlight></codeline>
<codeline lineno="145"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Manually<sp/>construct<sp/>the<sp/>Jacobian<sp/>for<sp/>d(ω×(ω×r))/dω</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="146"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>accounts<sp/>for<sp/>both<sp/>terms<sp/>in<sp/>the<sp/>derivative</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="147"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>3;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="148"><highlight class="normal"><sp/><sp/><sp/><sp/>Eigen::Vector3d<sp/>e_i<sp/>=<sp/>Eigen::Vector3d::Zero();</highlight></codeline>
<codeline lineno="149"><highlight class="normal"><sp/><sp/><sp/><sp/>e_i(i)<sp/>=<sp/>1.0;</highlight></codeline>
<codeline lineno="150"><highlight class="normal"></highlight></codeline>
<codeline lineno="151"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>First<sp/>term:<sp/>e_i<sp/>×<sp/>(ω<sp/>×<sp/>r)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="152"><highlight class="normal"><sp/><sp/><sp/><sp/>Eigen::Vector3d<sp/>term1<sp/>=<sp/>e_i.cross(omega.cross(r));</highlight></codeline>
<codeline lineno="153"><highlight class="normal"></highlight></codeline>
<codeline lineno="154"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Second<sp/>term:<sp/>ω<sp/>×<sp/>(e_i<sp/>×<sp/>r)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/><sp/><sp/>Eigen::Vector3d<sp/>term2<sp/>=<sp/>omega.cross(e_i.cross(r));</highlight></codeline>
<codeline lineno="156"><highlight class="normal"></highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Combined<sp/>effect</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/>omega_cross_r_jacobian.col(i)<sp/>=<sp/>term1<sp/>+<sp/>term2;</highlight></codeline>
<codeline lineno="159"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="160"><highlight class="normal"></highlight></codeline>
<codeline lineno="161"><highlight class="normal"><sp/><sp/>jacobian.block&lt;3,<sp/>3&gt;(MeasurementIndex::AX,<sp/><ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1AngularVelocity_1ab5079ed794f17df901a6199dc51d9da8" kindref="member">StateIndex::AngularVelocity::X</ref>)<sp/>=</highlight></codeline>
<codeline lineno="162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>R_BS<sp/>*<sp/>omega_cross_r_jacobian;</highlight></codeline>
<codeline lineno="163"><highlight class="normal"></highlight></codeline>
<codeline lineno="164"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>4.<sp/>Quaternion<sp/>effect<sp/>on<sp/>gravity</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Derive<sp/>Jacobian<sp/>for<sp/>rotation<sp/>of<sp/>gravity<sp/>vector<sp/>by<sp/>quaternion</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="166"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>For<sp/>gravity<sp/>vector<sp/>g_W<sp/>=<sp/>[0,<sp/>0,<sp/>g]^T<sp/>in<sp/>world<sp/>frame</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="167"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>rotated<sp/>gravity<sp/>in<sp/>body<sp/>frame<sp/>is:<sp/>g_B<sp/>=<sp/>q.inverse()<sp/>*<sp/>g_W<sp/>*<sp/>q</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="168"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>qw<sp/>=<sp/>q.w(),<sp/>qx<sp/>=<sp/>q.x(),<sp/>qy<sp/>=<sp/>q.y(),<sp/>qz<sp/>=<sp/>q.z();</highlight></codeline>
<codeline lineno="169"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>g<sp/>=<sp/>kGravity;</highlight></codeline>
<codeline lineno="170"><highlight class="normal"></highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Using<sp/>the<sp/>derivation<sp/>from<sp/>section<sp/>4.3<sp/>of<sp/>the<sp/>documentation:</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="172"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>For<sp/>g_W<sp/>=<sp/>[0,<sp/>0,<sp/>g]^T,<sp/>the<sp/>rotation<sp/>q.inverse()<sp/>*<sp/>g_W<sp/>gives:</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>g_B<sp/>=<sp/>g<sp/>*<sp/>[</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="174"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/>2(q_x*q_z<sp/>-<sp/>q_w*q_y)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="175"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/>2(q_y*q_z<sp/>+<sp/>q_w*q_x)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="176"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/>1<sp/>-<sp/>2(q_x^2<sp/>+<sp/>q_y^2)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="177"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="178"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="179"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>Jacobian<sp/>∂g_B/∂q<sp/>is<sp/>therefore:</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="180"><highlight class="normal"><sp/><sp/>Eigen::Matrix&lt;double,<sp/>3,<sp/>4&gt;<sp/>quaternion_gravity_jacobian;</highlight></codeline>
<codeline lineno="181"><highlight class="normal"><sp/><sp/>quaternion_gravity_jacobian<sp/>&lt;&lt;</highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>∂/∂q_w<sp/>*/</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>∂/∂q_x<sp/>*/</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>∂/∂q_y<sp/>*/</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>∂/∂q_z<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>-2*g*qy,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>2*g*qz,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-2*g*qw,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>2*g*qx,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>∂g_x/∂q</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>2*g*qx,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>2*g*qw,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>2*g*qz,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>2*g*qy,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>∂g_y/∂q</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-4*g*qx,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-4*g*qy,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>∂g_z/∂q</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="186"><highlight class="normal"></highlight></codeline>
<codeline lineno="187"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Apply<sp/>sensor-to-body<sp/>rotation<sp/>to<sp/>transform<sp/>the<sp/>Jacobian<sp/>to<sp/>sensor<sp/>frame</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="188"><highlight class="normal"><sp/><sp/>jacobian.block&lt;3,<sp/>4&gt;(MeasurementIndex::AX,<sp/><ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1a974ce211cf31eba33fd4a89c0706432f" kindref="member">StateIndex::Quaternion::W</ref>)<sp/>=</highlight></codeline>
<codeline lineno="189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>R_BS<sp/>*<sp/>quaternion_gravity_jacobian;</highlight></codeline>
<codeline lineno="190"><highlight class="normal"></highlight></codeline>
<codeline lineno="191"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>jacobian;</highlight></codeline>
<codeline lineno="192"><highlight class="normal">}</highlight></codeline>
<codeline lineno="193"><highlight class="normal"></highlight></codeline>
<codeline lineno="194" refid="classkinematic__arbiter_1_1sensors_1_1ImuSensorModel_1a5aa25072cbd538487d53217bdf59cff3" refkind="member"><highlight class="normal">Eigen::Matrix&lt;double,<sp/>6,<sp/>1&gt;<sp/><ref refid="classkinematic__arbiter_1_1sensors_1_1ImuSensorModel_1a5aa25072cbd538487d53217bdf59cff3" kindref="member">ImuSensorModel::GetPredictionModelInputs</ref>(</highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classkinematic__arbiter_1_1core_1_1MeasurementModelInterface_1abd357cd1e2aabe2107244532db30ece0" kindref="member">StateVector</ref>&amp;<sp/>state_before_prediction,</highlight></codeline>
<codeline lineno="196"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classkinematic__arbiter_1_1core_1_1MeasurementModelInterface_1af578e459eedc3354acd2339952c9df05" kindref="member">StateCovariance</ref>&amp;<sp/>,</highlight></codeline>
<codeline lineno="197"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classkinematic__arbiter_1_1core_1_1MeasurementModelInterface_1a9dfbdba5f6b255c3ac4c8ca73eb58a5b" kindref="member">ImuSensorModel::Base::DynamicVector</ref>&amp;<sp/>measurement_after_prediction,</highlight></codeline>
<codeline lineno="198"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>dt)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="199"><highlight class="normal"></highlight></codeline>
<codeline lineno="200"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Handle<sp/>edge<sp/>case<sp/>first</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="201"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(std::abs(dt)<sp/>&lt;<sp/><ref refid="namespacekinematic__arbiter_1_1sensors_1a687fad93ff58abc219b838b61df405cb" kindref="member">kEpsilon</ref>)<sp/>{</highlight></codeline>
<codeline lineno="202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>state_before_prediction.segment&lt;6&gt;(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1LinearAcceleration_1abcde4fc83b04286fb93abd48826b54fe" kindref="member">StateIndex::LinearAcceleration::Begin</ref>());</highlight></codeline>
<codeline lineno="203"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="204"><highlight class="normal"></highlight></codeline>
<codeline lineno="205"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Preprocess<sp/>sensor<sp/>measurements<sp/>==========================================</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="206"><highlight class="normal"><sp/><sp/><sp/><sp/>Vector3d<sp/>gyro<sp/>=<sp/>measurement_after_prediction.segment&lt;3&gt;(MeasurementIndex::GX);</highlight></codeline>
<codeline lineno="207"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Vector3d<sp/>accel<sp/>=<sp/>measurement_after_prediction.segment&lt;3&gt;(MeasurementIndex::AX);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="208"><highlight class="normal"></highlight></codeline>
<codeline lineno="209"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(config_.calibration_enabled)<sp/>{</highlight></codeline>
<codeline lineno="210"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gyro<sp/>-=<sp/>bias_estimator_.GetGyroBias();</highlight></codeline>
<codeline lineno="211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>accel<sp/>-=<sp/>bias_estimator_.GetAccelBias();</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="212"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="213"><highlight class="normal"></highlight></codeline>
<codeline lineno="214"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Matrix3d<sp/>R_SB<sp/>=<sp/>sensor_pose_in_body_frame_.rotation().transpose();</highlight></codeline>
<codeline lineno="215"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>const<sp/>Vector3d<sp/>r<sp/>=<sp/>sensor_pose_in_body_frame_.translation();</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="216"><highlight class="normal"></highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>//<sp/>Orientation<sp/>Update====================================</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="218"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Quaterniond<sp/>q_prev(</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/>state_before_prediction(StateIndex::Quaternion::W),</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="220"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/>state_before_prediction(StateIndex::Quaternion::X),</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="221"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/>state_before_prediction(StateIndex::Quaternion::Y),</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="222"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/>state_before_prediction(StateIndex::Quaternion::Z)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="223"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="224"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>q_prev.normalize();<sp/><sp/>//<sp/>Ensure<sp/>valid<sp/>quaternion</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="225"><highlight class="normal"></highlight></codeline>
<codeline lineno="226"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>Compute<sp/>gravity<sp/>vector<sp/>in<sp/>body<sp/>frame<sp/>with<sp/>stability<sp/>checks</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="227"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Vector3d<sp/>omega<sp/>=<sp/>R_SB<sp/>*<sp/>gyro;</highlight></codeline>
<codeline lineno="228"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Vector3d<sp/>current_lin_acc<sp/>=<sp/>state_before_prediction.segment&lt;3&gt;(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1LinearAcceleration_1abcde4fc83b04286fb93abd48826b54fe" kindref="member">StateIndex::LinearAcceleration::Begin</ref>());</highlight></codeline>
<codeline lineno="229"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Vector3d<sp/>current_ang_vel<sp/>=<sp/>state_before_prediction.segment&lt;3&gt;(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1AngularVelocity_1a582fc5f2b58d312404f599b8d00afa71" kindref="member">StateIndex::AngularVelocity::Begin</ref>());</highlight></codeline>
<codeline lineno="230"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>const<sp/>Vector3d<sp/>current_ang_acc<sp/>=<sp/>state_before_prediction.segment&lt;3&gt;(StateIndex::AngularAcceleration::Begin());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="231"><highlight class="normal"></highlight></codeline>
<codeline lineno="232"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Vector3d<sp/>gravity_vec<sp/>=<sp/>R_SB<sp/>*<sp/>accel</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="233"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-<sp/>current_lin_acc</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="234"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-<sp/>current_ang_acc.cross(r)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="235"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-<sp/>current_ang_vel.cross(current_ang_vel.cross(r))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="236"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-<sp/>2.0<sp/>*<sp/>current_ang_vel.cross(omega.cross(r));<sp/><sp/>//<sp/>Coriolis<sp/>term</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="237"><highlight class="normal"></highlight></codeline>
<codeline lineno="238"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>//<sp/>Fallback<sp/>to<sp/>predicted<sp/>gravity<sp/>if<sp/>measured<sp/>acceleration<sp/>is<sp/>unreliable</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="239"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>const<sp/>double<sp/>g_magnitude<sp/>=<sp/>gravity_vec.norm();</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="240"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>if(g_magnitude<sp/>&lt;<sp/>0.5<sp/>*<sp/>kGravity<sp/>||<sp/>g_magnitude<sp/>&gt;<sp/>1.5<sp/>*<sp/>kGravity)<sp/>{</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="241"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/>gravity_vec<sp/>=<sp/>q_prev.inverse()<sp/>*<sp/>Vector3d(0,<sp/>0,<sp/>kGravity);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="242"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="243"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>const<sp/>Vector3d<sp/>gravity<sp/>=<sp/>gravity_vec.normalized();</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="244"><highlight class="normal"></highlight></codeline>
<codeline lineno="245"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>//<sp/>2.<sp/>Madgwick<sp/>filter<sp/>update</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="246"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>const<sp/>Vector4d<sp/>F(</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="247"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/>2.0<sp/>*<sp/>(q_prev.x()<sp/>*<sp/>q_prev.z()<sp/>-<sp/>q_prev.w()<sp/>*<sp/>q_prev.y())<sp/>-<sp/>gravity.x(),</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="248"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/>2.0<sp/>*<sp/>(q_prev.w()<sp/>*<sp/>q_prev.x()<sp/>+<sp/>q_prev.y()<sp/>*<sp/>q_prev.z())<sp/>-<sp/>gravity.y(),</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="249"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/>2.0<sp/>*<sp/>(0.5<sp/>-<sp/>q_prev.x()<sp/>*<sp/>q_prev.x()<sp/>-<sp/>q_prev.y()<sp/>*<sp/>q_prev.y())<sp/>-<sp/>gravity.z(),</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="250"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/>0.0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="251"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="252"><highlight class="normal"></highlight></codeline>
<codeline lineno="253"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>const<sp/>double<sp/>qw<sp/>=<sp/>q_prev.w(),<sp/>qx<sp/>=<sp/>q_prev.x();</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="254"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>const<sp/>double<sp/>qy<sp/>=<sp/>q_prev.y(),<sp/>qz<sp/>=<sp/>q_prev.z();</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="255"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Matrix4d<sp/>J;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="256"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>J<sp/>&lt;&lt;<sp/>-2<sp/>*<sp/>qy,<sp/><sp/>2<sp/>*<sp/>qz,<sp/><sp/>-2<sp/>*<sp/>qw,<sp/>2<sp/>*<sp/>qx,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="257"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/>2<sp/>*<sp/>qx,<sp/><sp/>2<sp/>*<sp/>qw,<sp/><sp/><sp/>2<sp/>*<sp/>qz,<sp/>2<sp/>*<sp/>qy,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="258"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0.0,<sp/><sp/><sp/>-4<sp/>*<sp/>qx,<sp/><sp/>-4<sp/>*<sp/>qy,<sp/><sp/>0.0,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0.0,<sp/><sp/><sp/><sp/><sp/>0.0,<sp/><sp/><sp/><sp/><sp/>0.0,<sp/><sp/><sp/><sp/>0.0;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="260"><highlight class="normal"></highlight></codeline>
<codeline lineno="261"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Vector4d<sp/>gradient<sp/>=<sp/>(J.transpose()<sp/>*<sp/>F).normalized();</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="262"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>const<sp/>double<sp/>beta<sp/>=<sp/>50.0<sp/>*<sp/>dt;<sp/><sp/>//<sp/>Adaptive<sp/>beta</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="263"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>const<sp/>double<sp/>theta<sp/>=<sp/>beta<sp/>*<sp/>dt<sp/>*<sp/>gradient.norm();</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="264"><highlight class="normal"></highlight></codeline>
<codeline lineno="265"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Quaterniond<sp/>delta_q<sp/>=<sp/>Quaterniond::Identity();</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="266"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>if(theta<sp/>&gt;<sp/>kEpsilon)<sp/>{</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="267"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/>delta_q<sp/>=<sp/>Quaterniond(AngleAxisd(theta,<sp/>gradient.head&lt;3&gt;().normalized()));</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="268"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="269"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Quaterniond<sp/>q_new<sp/>=<sp/>(q_prev<sp/>*<sp/>delta_q).normalized();</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="270"><highlight class="normal"></highlight></codeline>
<codeline lineno="271"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Vector3d<sp/>angular_acceleration<sp/>=<sp/>(omega<sp/>-<sp/>current_ang_vel)<sp/>/<sp/>dt;</highlight></codeline>
<codeline lineno="272"><highlight class="normal"></highlight></codeline>
<codeline lineno="273"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>//<sp/>Linear<sp/>acceleration<sp/>in<sp/>world<sp/>frame</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="274"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>const<sp/>Vector3d<sp/>g_W(0.0,<sp/>0.0,<sp/>kGravity);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>const<sp/>Vector3d<sp/>linear_acceleration<sp/>=<sp/>q_new<sp/>*<sp/>(accel<sp/>-<sp/>R_SB.transpose()<sp/>*<sp/>g_W)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="276"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-<sp/>angular_acceleration.cross(r)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="277"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-<sp/>omega.cross(omega.cross(r));</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="278"><highlight class="normal"></highlight></codeline>
<codeline lineno="279"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compose<sp/>Output<sp/>==========================================================</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="280"><highlight class="normal"><sp/><sp/><sp/><sp/>Matrix&lt;double,<sp/>6,<sp/>1&gt;<sp/>inputs;</highlight></codeline>
<codeline lineno="281"><highlight class="normal"><sp/><sp/><sp/><sp/>inputs<sp/>&lt;&lt;<sp/>current_lin_acc,<sp/>angular_acceleration;</highlight></codeline>
<codeline lineno="282"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>inputs;</highlight></codeline>
<codeline lineno="283"><highlight class="normal">}</highlight></codeline>
<codeline lineno="284"><highlight class="normal"></highlight></codeline>
<codeline lineno="285" refid="classkinematic__arbiter_1_1sensors_1_1ImuSensorModel_1ac899c40e3d26a7e5aff1abc0e986fe35" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/><ref refid="classkinematic__arbiter_1_1sensors_1_1ImuSensorModel_1ac899c40e3d26a7e5aff1abc0e986fe35" kindref="member">ImuSensorModel::IsStationary</ref>(</highlight></codeline>
<codeline lineno="286"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classkinematic__arbiter_1_1core_1_1MeasurementModelInterface_1abd357cd1e2aabe2107244532db30ece0" kindref="member">StateVector</ref>&amp;<sp/>state,</highlight></codeline>
<codeline lineno="287"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classkinematic__arbiter_1_1core_1_1MeasurementModelInterface_1af578e459eedc3354acd2339952c9df05" kindref="member">StateCovariance</ref>&amp;<sp/>state_covariance,</highlight></codeline>
<codeline lineno="288"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classkinematic__arbiter_1_1sensors_1_1ImuSensorModel_1a6c6ee31c6adbed7273d71e556662dabb" kindref="member">Vector</ref>&amp;<sp/>measurement)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="289"><highlight class="normal"></highlight></codeline>
<codeline lineno="290"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Extract<sp/>measurements<sp/>directly<sp/>using<sp/>segment</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="291"><highlight class="normal"><sp/><sp/>Eigen::Vector3d<sp/>measured_accel<sp/>=<sp/>measurement.segment&lt;3&gt;(MeasurementIndex::AX);</highlight></codeline>
<codeline lineno="292"><highlight class="normal"></highlight></codeline>
<codeline lineno="293"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>acceleration<sp/>norm<sp/>(should<sp/>be<sp/>close<sp/>to<sp/>gravity<sp/>when<sp/>stationary)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="294"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>accel_norm<sp/>=<sp/>measured_accel.norm();</highlight></codeline>
<codeline lineno="295"><highlight class="normal"></highlight></codeline>
<codeline lineno="296"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Pre-compute<sp/>critical<sp/>values<sp/>for<sp/>different<sp/>degrees<sp/>of<sp/>freedom</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="297"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>critical_value6dof<sp/>=<sp/><ref refid="namespacekinematic__arbiter_1_1utils_1af02a244e2c612066ac33228be4627067" kindref="member">utils::CalculateChiSquareCriticalValueNDof</ref>(5,<sp/>config_.stationary_confidence_threshold);</highlight></codeline>
<codeline lineno="298"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>critical_value1dof<sp/>=<sp/><ref refid="namespacekinematic__arbiter_1_1utils_1af02a244e2c612066ac33228be4627067" kindref="member">utils::CalculateChiSquareCriticalValueNDof</ref>(0,<sp/>config_.stationary_confidence_threshold);</highlight></codeline>
<codeline lineno="299"><highlight class="normal"></highlight></codeline>
<codeline lineno="300"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>Test<sp/>state<sp/>velocities<sp/>(6-DOF)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="301"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>state_vel_idx<sp/>=<sp/><ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1LinearVelocity_1a0e89a91c515a8082579c3da82e694558" kindref="member">StateIndex::LinearVelocity::X</ref>;</highlight></codeline>
<codeline lineno="302"><highlight class="normal"><sp/><sp/>Eigen::Matrix&lt;double,<sp/>6,<sp/>1&gt;<sp/>state_vel<sp/>=<sp/>state.segment&lt;6&gt;(state_vel_idx);</highlight></codeline>
<codeline lineno="303"><highlight class="normal"><sp/><sp/>Eigen::Matrix&lt;double,<sp/>6,<sp/>6&gt;<sp/>state_vel_cov<sp/>=<sp/>state_covariance.block&lt;6,<sp/>6&gt;(state_vel_idx,<sp/>state_vel_idx);</highlight></codeline>
<codeline lineno="304"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>is_state_vel0<sp/>=<sp/>state_vel.dot(state_vel_cov.llt().solve(state_vel))<sp/>&lt;<sp/>critical_value6dof;</highlight></codeline>
<codeline lineno="305"><highlight class="normal"></highlight></codeline>
<codeline lineno="306"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>2.<sp/>Test<sp/>state<sp/>accelerations<sp/>(6-DOF)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="307"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>state_acc_idx<sp/>=<sp/><ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1LinearAcceleration_1aec74bb1d8af0022628c73105f68ab432" kindref="member">StateIndex::LinearAcceleration::X</ref>;</highlight></codeline>
<codeline lineno="308"><highlight class="normal"><sp/><sp/>Eigen::Matrix&lt;double,<sp/>6,<sp/>1&gt;<sp/>state_acc<sp/>=<sp/>state.segment&lt;6&gt;(state_acc_idx);</highlight></codeline>
<codeline lineno="309"><highlight class="normal"><sp/><sp/>Eigen::Matrix&lt;double,<sp/>6,<sp/>6&gt;<sp/>state_acc_cov<sp/>=<sp/>state_covariance.block&lt;6,<sp/>6&gt;(state_acc_idx,<sp/>state_acc_idx);</highlight></codeline>
<codeline lineno="310"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>is_state_acc0<sp/>=<sp/>state_acc.dot(state_acc_cov.llt().solve(state_acc))<sp/>&lt;<sp/>critical_value6dof;</highlight></codeline>
<codeline lineno="311"><highlight class="normal"></highlight></codeline>
<codeline lineno="312"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>3.<sp/>Test<sp/>IMU<sp/>acceleration<sp/>norm<sp/>against<sp/>gravity<sp/>(1-DOF)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="313"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>gravity_diff<sp/>=<sp/>accel_norm<sp/>-<sp/>kGravity;</highlight></codeline>
<codeline lineno="314"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>accel_norm_var<sp/>=<sp/>this-&gt;measurement_covariance_.block&lt;3,<sp/>3&gt;(MeasurementIndex::AX,<sp/>MeasurementIndex::AX).trace();</highlight></codeline>
<codeline lineno="315"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>gravity_mahalanobis<sp/>=<sp/>(gravity_diff<sp/>*<sp/>gravity_diff)<sp/>/<sp/>(accel_norm_var<sp/>+<sp/>kGravityVariance);</highlight></codeline>
<codeline lineno="316"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>is_imu_accel_gravity<sp/>=<sp/>gravity_mahalanobis<sp/>&lt;<sp/>critical_value1dof;</highlight></codeline>
<codeline lineno="317"><highlight class="normal"></highlight></codeline>
<codeline lineno="318"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Ignoring<sp/>angular<sp/>velocity<sp/>from<sp/>IMU<sp/>for<sp/>now<sp/>due<sp/>to<sp/>confounding<sp/>bias<sp/>effects</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="319"><highlight class="normal"></highlight></codeline>
<codeline lineno="320"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>is_state_vel0<sp/>&amp;&amp;<sp/>is_state_acc0<sp/>&amp;&amp;<sp/>is_imu_accel_gravity;</highlight></codeline>
<codeline lineno="321"><highlight class="normal">}</highlight></codeline>
<codeline lineno="322"><highlight class="normal"></highlight></codeline>
<codeline lineno="332" refid="classkinematic__arbiter_1_1sensors_1_1ImuSensorModel_1a1d864b9804c270159a6b7b07fd4b8dc9" refkind="member"><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classkinematic__arbiter_1_1sensors_1_1ImuSensorModel_1a53abd5b1cb4baf98e8d2ec13dbe4bd0e" kindref="member">ImuSensorModel::StateFlags</ref><sp/><ref refid="classkinematic__arbiter_1_1sensors_1_1ImuSensorModel_1a1d864b9804c270159a6b7b07fd4b8dc9" kindref="member">ImuSensorModel::GetInitializableStates</ref>()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="333"><highlight class="normal"><sp/><sp/><ref refid="classkinematic__arbiter_1_1core_1_1MeasurementModelInterface_1acced1b6fad51798933f1526abed8bdf8" kindref="member">StateFlags</ref><sp/>flags<sp/>=<sp/>StateFlags::Zero();</highlight></codeline>
<codeline lineno="334"><highlight class="normal"></highlight></codeline>
<codeline lineno="335"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>IMU<sp/>can<sp/>initialize<sp/>angular<sp/>velocity</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="336"><highlight class="normal"><sp/><sp/>flags[<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1AngularVelocity_1ab5079ed794f17df901a6199dc51d9da8" kindref="member">StateIndex::AngularVelocity::X</ref>]<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="337"><highlight class="normal"><sp/><sp/>flags[<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1AngularVelocity_1a6a36392e699a5d9c1fa1aa81a630796a" kindref="member">StateIndex::AngularVelocity::Y</ref>]<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="338"><highlight class="normal"><sp/><sp/>flags[<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1AngularVelocity_1a21bf3e25ae81f3cfef8d9d0e6b12fcfb" kindref="member">StateIndex::AngularVelocity::Z</ref>]<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="339"><highlight class="normal"></highlight></codeline>
<codeline lineno="340"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>IMU<sp/>can<sp/>initialize<sp/>linear<sp/>acceleration</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="341"><highlight class="normal"><sp/><sp/>flags[<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1LinearAcceleration_1aec74bb1d8af0022628c73105f68ab432" kindref="member">StateIndex::LinearAcceleration::X</ref>]<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="342"><highlight class="normal"><sp/><sp/>flags[<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1LinearAcceleration_1a0a0cde579e6f27c1eae474023840aa46" kindref="member">StateIndex::LinearAcceleration::Y</ref>]<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="343"><highlight class="normal"><sp/><sp/>flags[<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1LinearAcceleration_1ac13e197ca37f472101cc14a2106fdb68" kindref="member">StateIndex::LinearAcceleration::Z</ref>]<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="344"><highlight class="normal"></highlight></codeline>
<codeline lineno="345"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>IMU<sp/>can<sp/>initialize<sp/>roll<sp/>and<sp/>pitch<sp/>(but<sp/>not<sp/>yaw)<sp/>from<sp/>gravity</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="346"><highlight class="normal"><sp/><sp/>flags[<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1a974ce211cf31eba33fd4a89c0706432f" kindref="member">StateIndex::Quaternion::W</ref>]<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="347"><highlight class="normal"><sp/><sp/>flags[<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1a16846a86810c4a3c7b1651bd10586cfe" kindref="member">StateIndex::Quaternion::X</ref>]<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="348"><highlight class="normal"><sp/><sp/>flags[<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1af1d78b2f18147bf1abec5a47d984e63c" kindref="member">StateIndex::Quaternion::Y</ref>]<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="349"><highlight class="normal"></highlight></codeline>
<codeline lineno="350"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>When<sp/>stationary,<sp/>can<sp/>also<sp/>initialize<sp/>angular<sp/>acceleration<sp/>(to<sp/>zero)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="351"><highlight class="normal"><sp/><sp/>flags[<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1AngularAcceleration_1ad54f3ad255cbacc2ad29b7c97a3f1f5a" kindref="member">StateIndex::AngularAcceleration::X</ref>]<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="352"><highlight class="normal"><sp/><sp/>flags[<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1AngularAcceleration_1aaea479bb5c69487e92133f7a53b295e6" kindref="member">StateIndex::AngularAcceleration::Y</ref>]<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="353"><highlight class="normal"><sp/><sp/>flags[<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1AngularAcceleration_1a6d5582b4588663cb994a2d751e68badf" kindref="member">StateIndex::AngularAcceleration::Z</ref>]<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="354"><highlight class="normal"></highlight></codeline>
<codeline lineno="355"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>flags;</highlight></codeline>
<codeline lineno="356"><highlight class="normal">}</highlight></codeline>
<codeline lineno="357"><highlight class="normal"></highlight></codeline>
<codeline lineno="371" refid="classkinematic__arbiter_1_1sensors_1_1ImuSensorModel_1a3aab1963c7316f0e402277d9032fa87a" refkind="member"><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classkinematic__arbiter_1_1sensors_1_1ImuSensorModel_1a53abd5b1cb4baf98e8d2ec13dbe4bd0e" kindref="member">ImuSensorModel::StateFlags</ref><sp/><ref refid="classkinematic__arbiter_1_1sensors_1_1ImuSensorModel_1a3aab1963c7316f0e402277d9032fa87a" kindref="member">ImuSensorModel::InitializeState</ref>(</highlight></codeline>
<codeline lineno="372"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classkinematic__arbiter_1_1core_1_1MeasurementModelInterface_1a9dfbdba5f6b255c3ac4c8ca73eb58a5b" kindref="member">ImuSensorModel::Base::DynamicVector</ref>&amp;<sp/>measurement,</highlight></codeline>
<codeline lineno="373"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classkinematic__arbiter_1_1core_1_1MeasurementModelInterface_1acced1b6fad51798933f1526abed8bdf8" kindref="member">StateFlags</ref>&amp;<sp/>,</highlight></codeline>
<codeline lineno="374"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classkinematic__arbiter_1_1core_1_1MeasurementModelInterface_1abd357cd1e2aabe2107244532db30ece0" kindref="member">StateVector</ref>&amp;<sp/>state,</highlight></codeline>
<codeline lineno="375"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classkinematic__arbiter_1_1core_1_1MeasurementModelInterface_1af578e459eedc3354acd2339952c9df05" kindref="member">StateCovariance</ref>&amp;<sp/>covariance)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="376"><highlight class="normal"></highlight></codeline>
<codeline lineno="377"><highlight class="normal"><sp/><sp/>ValidateMeasurementSize(measurement);</highlight></codeline>
<codeline lineno="378"><highlight class="normal"></highlight></codeline>
<codeline lineno="379"><highlight class="normal"><sp/><sp/><ref refid="classkinematic__arbiter_1_1core_1_1MeasurementModelInterface_1acced1b6fad51798933f1526abed8bdf8" kindref="member">StateFlags</ref><sp/>initialized_states<sp/>=<sp/>StateFlags::Zero();</highlight></codeline>
<codeline lineno="380"><highlight class="normal"></highlight></codeline>
<codeline lineno="381"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Extract<sp/>gyro<sp/>and<sp/>accelerometer<sp/>measurements</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="382"><highlight class="normal"><sp/><sp/>Eigen::Vector3d<sp/>gyro<sp/>=<sp/>measurement.segment&lt;3&gt;(0);</highlight></codeline>
<codeline lineno="383"><highlight class="normal"><sp/><sp/>Eigen::Vector3d<sp/>accel<sp/>=<sp/>measurement.segment&lt;3&gt;(3);</highlight></codeline>
<codeline lineno="384"><highlight class="normal"></highlight></codeline>
<codeline lineno="385"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Transform<sp/>to<sp/>body<sp/>frame</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="386"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Eigen::Matrix3d<sp/>R_SB<sp/>=<sp/>sensor_pose_in_body_frame_.rotation();</highlight></codeline>
<codeline lineno="387"><highlight class="normal"></highlight></codeline>
<codeline lineno="388"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Apply<sp/>bias<sp/>correction<sp/>if<sp/>calibration<sp/>is<sp/>enabled</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="389"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(config_.calibration_enabled)<sp/>{</highlight></codeline>
<codeline lineno="390"><highlight class="normal"><sp/><sp/><sp/><sp/>gyro<sp/>-=<sp/>bias_estimator_.GetGyroBias();</highlight></codeline>
<codeline lineno="391"><highlight class="normal"><sp/><sp/><sp/><sp/>accel<sp/>-=<sp/>bias_estimator_.GetAccelBias();</highlight></codeline>
<codeline lineno="392"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="393"><highlight class="normal"></highlight></codeline>
<codeline lineno="394"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Transform<sp/>to<sp/>body<sp/>frame</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="395"><highlight class="normal"><sp/><sp/>Eigen::Vector3d<sp/>omega_body<sp/>=<sp/>R_SB<sp/>*<sp/>gyro;</highlight></codeline>
<codeline lineno="396"><highlight class="normal"><sp/><sp/>Eigen::Vector3d<sp/>accel_body<sp/>=<sp/>R_SB<sp/>*<sp/>accel;</highlight></codeline>
<codeline lineno="397"><highlight class="normal"></highlight></codeline>
<codeline lineno="398"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>angular<sp/>velocity</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="399"><highlight class="normal"><sp/><sp/>state.segment&lt;3&gt;(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1AngularVelocity_1a582fc5f2b58d312404f599b8d00afa71" kindref="member">StateIndex::AngularVelocity::Begin</ref>())<sp/>=<sp/>omega_body;</highlight></codeline>
<codeline lineno="400"><highlight class="normal"></highlight></codeline>
<codeline lineno="401"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Set<sp/>angular<sp/>velocity<sp/>covariance</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="402"><highlight class="normal"><sp/><sp/>Eigen::Matrix3d<sp/>gyro_cov<sp/>=<sp/>measurement_covariance_.block&lt;3,<sp/>3&gt;(0,<sp/>0);</highlight></codeline>
<codeline lineno="403"><highlight class="normal"><sp/><sp/>Eigen::Matrix3d<sp/>omega_body_cov<sp/>=<sp/>R_SB<sp/>*<sp/>gyro_cov<sp/>*<sp/>R_SB.transpose();</highlight></codeline>
<codeline lineno="404"><highlight class="normal"><sp/><sp/>covariance.block&lt;3,<sp/>3&gt;(</highlight></codeline>
<codeline lineno="405"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1AngularVelocity_1a582fc5f2b58d312404f599b8d00afa71" kindref="member">StateIndex::AngularVelocity::Begin</ref>(),</highlight></codeline>
<codeline lineno="406"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1AngularVelocity_1a582fc5f2b58d312404f599b8d00afa71" kindref="member">StateIndex::AngularVelocity::Begin</ref>())<sp/>=<sp/>omega_body_cov;</highlight></codeline>
<codeline lineno="407"><highlight class="normal"></highlight></codeline>
<codeline lineno="408"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Mark<sp/>angular<sp/>velocity<sp/>as<sp/>initialized</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="409"><highlight class="normal"><sp/><sp/>initialized_states[<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1AngularVelocity_1ab5079ed794f17df901a6199dc51d9da8" kindref="member">StateIndex::AngularVelocity::X</ref>]<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="410"><highlight class="normal"><sp/><sp/>initialized_states[<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1AngularVelocity_1a6a36392e699a5d9c1fa1aa81a630796a" kindref="member">StateIndex::AngularVelocity::Y</ref>]<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="411"><highlight class="normal"><sp/><sp/>initialized_states[<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1AngularVelocity_1a21bf3e25ae81f3cfef8d9d0e6b12fcfb" kindref="member">StateIndex::AngularVelocity::Z</ref>]<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="412"><highlight class="normal"></highlight></codeline>
<codeline lineno="413"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Calculate<sp/>accelerometer<sp/>covariance<sp/>in<sp/>body<sp/>frame</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="414"><highlight class="normal"><sp/><sp/>Eigen::Matrix3d<sp/>accel_cov<sp/>=<sp/>measurement_covariance_.block&lt;3,<sp/>3&gt;(3,<sp/>3);</highlight></codeline>
<codeline lineno="415"><highlight class="normal"><sp/><sp/>Eigen::Matrix3d<sp/>accel_body_cov<sp/>=<sp/>R_SB<sp/>*<sp/>accel_cov<sp/>*<sp/>R_SB.transpose();</highlight></codeline>
<codeline lineno="416"><highlight class="normal"></highlight></codeline>
<codeline lineno="417"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>if<sp/>IMU<sp/>is<sp/>stationary<sp/>for<sp/>orientation<sp/>initialization</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="418"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>is_stationary<sp/>=<sp/>IsStationary(state,<sp/>covariance,<sp/>measurement);</highlight></codeline>
<codeline lineno="419"><highlight class="normal"></highlight></codeline>
<codeline lineno="420"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Always<sp/>extract<sp/>current<sp/>yaw<sp/>regardless<sp/>of<sp/>validity</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="421"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Extract<sp/>current<sp/>quaternion</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="422"><highlight class="normal"><sp/><sp/>Eigen::Quaterniond<sp/>current_q(</highlight></codeline>
<codeline lineno="423"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>state(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1a974ce211cf31eba33fd4a89c0706432f" kindref="member">StateIndex::Quaternion::W</ref>),</highlight></codeline>
<codeline lineno="424"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>state(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1a16846a86810c4a3c7b1651bd10586cfe" kindref="member">StateIndex::Quaternion::X</ref>),</highlight></codeline>
<codeline lineno="425"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>state(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1af1d78b2f18147bf1abec5a47d984e63c" kindref="member">StateIndex::Quaternion::Y</ref>),</highlight></codeline>
<codeline lineno="426"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>state(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1a8a8ad785fbd7f06509eae6b27b7d20c9" kindref="member">StateIndex::Quaternion::Z</ref>)</highlight></codeline>
<codeline lineno="427"><highlight class="normal"><sp/><sp/>);</highlight></codeline>
<codeline lineno="428"><highlight class="normal"><sp/><sp/>current_q.normalize();</highlight></codeline>
<codeline lineno="429"><highlight class="normal"></highlight></codeline>
<codeline lineno="430"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Convert<sp/>to<sp/>rotation<sp/>matrix<sp/>and<sp/>extract<sp/>yaw</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="431"><highlight class="normal"><sp/><sp/>Eigen::Matrix3d<sp/>rot_matrix<sp/>=<sp/>current_q.toRotationMatrix();</highlight></codeline>
<codeline lineno="432"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>current_yaw<sp/>=<sp/>std::atan2(rot_matrix(1,<sp/>0),<sp/>rot_matrix(0,<sp/>0));</highlight></codeline>
<codeline lineno="433"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(is_stationary<sp/>||<sp/>(accel_body.norm()<sp/>&gt;<sp/>0.5<sp/>*<sp/>kGravity<sp/>&amp;&amp;<sp/>accel_body.norm()<sp/>&lt;<sp/>1.5<sp/>*<sp/>kGravity))<sp/>{</highlight></codeline>
<codeline lineno="434"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>ay<sp/>=<sp/>accel_body(1)/accel_body.norm();</highlight></codeline>
<codeline lineno="435"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>az<sp/>=<sp/>accel_body(2)/accel_body.norm();</highlight></codeline>
<codeline lineno="436"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>roll<sp/>=<sp/>std::atan2(ay,<sp/>az);</highlight></codeline>
<codeline lineno="437"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Calculate<sp/>pitch<sp/>from<sp/>accelerometer<sp/>when<sp/>stationary</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="438"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>ax<sp/>=<sp/>accel_body(0);</highlight></codeline>
<codeline lineno="439"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>pitch<sp/>=<sp/>std::asin(-ax<sp/>/<sp/>accel_body.norm());</highlight></codeline>
<codeline lineno="440"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>roll_pitch_variance<sp/>=<sp/>(M_PI/6.0)<sp/>*<sp/>(M_PI/6.0);</highlight></codeline>
<codeline lineno="441"><highlight class="normal"></highlight></codeline>
<codeline lineno="442"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(is_stationary)<sp/>{</highlight></codeline>
<codeline lineno="443"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Calculate<sp/>roll<sp/>from<sp/>accelerometer<sp/>when<sp/>stationary</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="444"><highlight class="normal"><sp/><sp/><sp/><sp/>ay<sp/>=<sp/>accel_body(1);</highlight></codeline>
<codeline lineno="445"><highlight class="normal"><sp/><sp/><sp/><sp/>az<sp/>=<sp/>accel_body(2);</highlight></codeline>
<codeline lineno="446"><highlight class="normal"><sp/><sp/><sp/><sp/>roll<sp/>=<sp/>std::atan2(ay,<sp/>az);</highlight></codeline>
<codeline lineno="447"><highlight class="normal"></highlight></codeline>
<codeline lineno="448"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Propagate<sp/>uncertainty<sp/>for<sp/>roll</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="449"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>d_roll_d_ay<sp/>=<sp/>std::abs(az<sp/>/<sp/>(ay*ay<sp/>+<sp/>az*az));</highlight></codeline>
<codeline lineno="450"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>d_roll_d_az<sp/>=<sp/>std::abs(-ay<sp/>/<sp/>(ay*ay<sp/>+<sp/>az*az));</highlight></codeline>
<codeline lineno="451"><highlight class="normal"><sp/><sp/><sp/><sp/>Eigen::Vector2d<sp/>d_roll_d_ayz;</highlight></codeline>
<codeline lineno="452"><highlight class="normal"><sp/><sp/><sp/><sp/>d_roll_d_ayz<sp/>&lt;&lt;<sp/>d_roll_d_ay,<sp/>d_roll_d_az;</highlight></codeline>
<codeline lineno="453"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>roll_var<sp/>=<sp/>d_roll_d_ayz.transpose()<sp/>*</highlight></codeline>
<codeline lineno="454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>accel_body_cov.block&lt;2,2&gt;(1,1)<sp/>*</highlight></codeline>
<codeline lineno="455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>d_roll_d_ayz;</highlight></codeline>
<codeline lineno="456"><highlight class="normal"></highlight></codeline>
<codeline lineno="457"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Calculate<sp/>pitch<sp/>from<sp/>accelerometer<sp/>when<sp/>stationary</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="458"><highlight class="normal"><sp/><sp/><sp/><sp/>ax<sp/>=<sp/>accel_body(0);</highlight></codeline>
<codeline lineno="459"><highlight class="normal"><sp/><sp/><sp/><sp/>pitch<sp/>=<sp/>std::asin(-ax<sp/>/<sp/>kGravity);</highlight></codeline>
<codeline lineno="460"><highlight class="normal"></highlight></codeline>
<codeline lineno="461"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Propagate<sp/>uncertainty<sp/>for<sp/>pitch</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="462"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>d_pitch_d_ax<sp/>=<sp/>std::abs(1.0<sp/>/<sp/>(kGravity<sp/>*<sp/>std::sqrt(1.0<sp/>-<sp/>(ax*ax)/(kGravity*kGravity))));</highlight></codeline>
<codeline lineno="463"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>pitch_var<sp/>=<sp/>d_pitch_d_ax<sp/>*<sp/>accel_body_cov(0,0)<sp/>*<sp/>d_pitch_d_ax;</highlight></codeline>
<codeline lineno="464"><highlight class="normal"></highlight></codeline>
<codeline lineno="465"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Set<sp/>appropriate<sp/>covariance<sp/>for<sp/>quaternion<sp/>components</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="466"><highlight class="normal"><sp/><sp/><sp/><sp/>roll_pitch_variance<sp/>=<sp/>std::max(roll_var,<sp/>pitch_var);</highlight></codeline>
<codeline lineno="467"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="468"><highlight class="normal"></highlight></codeline>
<codeline lineno="469"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>rotation<sp/>matrix<sp/>from<sp/>roll,<sp/>pitch,<sp/>and<sp/>yaw</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="470"><highlight class="normal"><sp/><sp/><sp/><sp/>Eigen::Matrix3d<sp/>roll_rot<sp/>=<sp/>Eigen::AngleAxisd(roll,<sp/>Eigen::Vector3d::UnitX()).toRotationMatrix();</highlight></codeline>
<codeline lineno="471"><highlight class="normal"><sp/><sp/><sp/><sp/>Eigen::Matrix3d<sp/>pitch_rot<sp/>=<sp/>Eigen::AngleAxisd(pitch,<sp/>Eigen::Vector3d::UnitY()).toRotationMatrix();</highlight></codeline>
<codeline lineno="472"><highlight class="normal"><sp/><sp/><sp/><sp/>Eigen::Matrix3d<sp/>yaw_rot<sp/>=<sp/>Eigen::AngleAxisd(current_yaw,<sp/>Eigen::Vector3d::UnitZ()).toRotationMatrix();</highlight></codeline>
<codeline lineno="473"><highlight class="normal"></highlight></codeline>
<codeline lineno="474"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Combine<sp/>rotations<sp/>in<sp/>XYZ<sp/>order<sp/>(roll-pitch-yaw)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="475"><highlight class="normal"><sp/><sp/><sp/><sp/>rot_matrix<sp/>=<sp/>roll_rot<sp/>*<sp/>pitch_rot<sp/>*<sp/>yaw_rot;</highlight></codeline>
<codeline lineno="476"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Convert<sp/>to<sp/>quaternion</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="477"><highlight class="normal"><sp/><sp/><sp/><sp/>Eigen::Quaterniond<sp/>q(rot_matrix);</highlight></codeline>
<codeline lineno="478"><highlight class="normal"><sp/><sp/><sp/><sp/>q.normalize();</highlight></codeline>
<codeline lineno="479"><highlight class="normal"></highlight></codeline>
<codeline lineno="480"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Update<sp/>state<sp/>with<sp/>quaternion</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="481"><highlight class="normal"><sp/><sp/><sp/><sp/>state(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1a974ce211cf31eba33fd4a89c0706432f" kindref="member">StateIndex::Quaternion::W</ref>)<sp/>=<sp/>q.w();</highlight></codeline>
<codeline lineno="482"><highlight class="normal"><sp/><sp/><sp/><sp/>state(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1a16846a86810c4a3c7b1651bd10586cfe" kindref="member">StateIndex::Quaternion::X</ref>)<sp/>=<sp/>q.x();</highlight></codeline>
<codeline lineno="483"><highlight class="normal"><sp/><sp/><sp/><sp/>state(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1af1d78b2f18147bf1abec5a47d984e63c" kindref="member">StateIndex::Quaternion::Y</ref>)<sp/>=<sp/>q.y();</highlight></codeline>
<codeline lineno="484"><highlight class="normal"><sp/><sp/><sp/><sp/>state(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1a8a8ad785fbd7f06509eae6b27b7d20c9" kindref="member">StateIndex::Quaternion::Z</ref>)<sp/>=<sp/>q.z();</highlight></codeline>
<codeline lineno="485"><highlight class="normal"></highlight></codeline>
<codeline lineno="486"><highlight class="normal"></highlight></codeline>
<codeline lineno="487"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>mask<sp/>matrix<sp/>for<sp/>yaw-related<sp/>components<sp/>(W<sp/>and<sp/>Z)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="488"><highlight class="normal"><sp/><sp/><sp/><sp/>Eigen::Matrix4d<sp/>yaw_mask<sp/>=<sp/>Eigen::Matrix4d::Zero();</highlight></codeline>
<codeline lineno="489"><highlight class="normal"><sp/><sp/><sp/><sp/>yaw_mask(0,<sp/>0)<sp/>=<sp/>1.0;<sp/></highlight><highlight class="comment">//<sp/>W<sp/>component</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="490"><highlight class="normal"><sp/><sp/><sp/><sp/>yaw_mask(3,<sp/>3)<sp/>=<sp/>1.0;<sp/></highlight><highlight class="comment">//<sp/>Z<sp/>component</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="491"><highlight class="normal"></highlight></codeline>
<codeline lineno="492"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>mask<sp/>for<sp/>roll/pitch<sp/>components<sp/>(W,<sp/>X,<sp/>Y)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="493"><highlight class="normal"><sp/><sp/><sp/><sp/>Eigen::Matrix4d<sp/>roll_pitch_mask<sp/>=<sp/>Eigen::Matrix4d::Identity()<sp/>-<sp/>yaw_mask;</highlight></codeline>
<codeline lineno="494"><highlight class="normal"></highlight></codeline>
<codeline lineno="495"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Combine<sp/>the<sp/>covariances:</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="496"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>-<sp/>For<sp/>roll/pitch<sp/>components:<sp/>use<sp/>the<sp/>newly<sp/>calculated<sp/>variance</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="497"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>-<sp/>For<sp/>yaw<sp/>components:<sp/>preserve<sp/>the<sp/>original<sp/>covariance<sp/>magnitude</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="498"><highlight class="normal"><sp/><sp/><sp/><sp/>covariance.block&lt;4,<sp/>4&gt;(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1af3e01b65049a657408ba89e583c1e5ca" kindref="member">StateIndex::Quaternion::Begin</ref>(),<sp/><ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1af3e01b65049a657408ba89e583c1e5ca" kindref="member">StateIndex::Quaternion::Begin</ref>())<sp/>=</highlight></codeline>
<codeline lineno="499"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(roll_pitch_mask<sp/>*<sp/>roll_pitch_variance)<sp/>+</highlight></codeline>
<codeline lineno="500"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(yaw_mask<sp/>*<sp/>covariance.block&lt;4,<sp/>4&gt;(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1af3e01b65049a657408ba89e583c1e5ca" kindref="member">StateIndex::Quaternion::Begin</ref>(),<sp/><ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1af3e01b65049a657408ba89e583c1e5ca" kindref="member">StateIndex::Quaternion::Begin</ref>()).norm());</highlight></codeline>
<codeline lineno="501"><highlight class="normal"></highlight></codeline>
<codeline lineno="502"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Mark<sp/>roll<sp/>and<sp/>pitch<sp/>as<sp/>initialized<sp/>(quaternion<sp/>components)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="503"><highlight class="normal"><sp/><sp/><sp/><sp/>initialized_states[<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1a974ce211cf31eba33fd4a89c0706432f" kindref="member">StateIndex::Quaternion::W</ref>]<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="504"><highlight class="normal"><sp/><sp/><sp/><sp/>initialized_states[<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1a16846a86810c4a3c7b1651bd10586cfe" kindref="member">StateIndex::Quaternion::X</ref>]<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="505"><highlight class="normal"><sp/><sp/><sp/><sp/>initialized_states[<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1Quaternion_1af1d78b2f18147bf1abec5a47d984e63c" kindref="member">StateIndex::Quaternion::Y</ref>]<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="506"><highlight class="normal"></highlight></codeline>
<codeline lineno="507"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>When<sp/>stationary,<sp/>linear<sp/>acceleration<sp/>should<sp/>be<sp/>zero<sp/>in<sp/>inertial<sp/>frame</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="508"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>and<sp/>angular<sp/>acceleration<sp/>should<sp/>be<sp/>zero</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="509"><highlight class="normal"><sp/><sp/><sp/><sp/>state.segment&lt;3&gt;(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1LinearAcceleration_1abcde4fc83b04286fb93abd48826b54fe" kindref="member">StateIndex::LinearAcceleration::Begin</ref>()).setZero();</highlight></codeline>
<codeline lineno="510"><highlight class="normal"><sp/><sp/><sp/><sp/>state.segment&lt;3&gt;(<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1AngularAcceleration_1aba70ff56c29cff8b0cd60ddd365d093f" kindref="member">StateIndex::AngularAcceleration::Begin</ref>()).setZero();</highlight></codeline>
<codeline lineno="511"><highlight class="normal"></highlight></codeline>
<codeline lineno="512"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Set<sp/>covariance<sp/>for<sp/>linear<sp/>and<sp/>angular<sp/>acceleration</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="513"><highlight class="normal"><sp/><sp/><sp/><sp/>covariance.block&lt;3,<sp/>3&gt;(</highlight></codeline>
<codeline lineno="514"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1LinearAcceleration_1abcde4fc83b04286fb93abd48826b54fe" kindref="member">StateIndex::LinearAcceleration::Begin</ref>(),</highlight></codeline>
<codeline lineno="515"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1LinearAcceleration_1abcde4fc83b04286fb93abd48826b54fe" kindref="member">StateIndex::LinearAcceleration::Begin</ref>())<sp/>=<sp/>accel_body_cov;</highlight></codeline>
<codeline lineno="516"><highlight class="normal"></highlight></codeline>
<codeline lineno="517"><highlight class="normal"><sp/><sp/><sp/><sp/>covariance.block&lt;3,<sp/>3&gt;(</highlight></codeline>
<codeline lineno="518"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1AngularAcceleration_1aba70ff56c29cff8b0cd60ddd365d093f" kindref="member">StateIndex::AngularAcceleration::Begin</ref>(),</highlight></codeline>
<codeline lineno="519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1AngularAcceleration_1aba70ff56c29cff8b0cd60ddd365d093f" kindref="member">StateIndex::AngularAcceleration::Begin</ref>())<sp/>=<sp/>omega_body_cov;</highlight></codeline>
<codeline lineno="520"><highlight class="normal"></highlight></codeline>
<codeline lineno="521"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Mark<sp/>linear<sp/>and<sp/>angular<sp/>acceleration<sp/>as<sp/>initialized</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="522"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>3;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="523"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>initialized_states[<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1LinearAcceleration_1abcde4fc83b04286fb93abd48826b54fe" kindref="member">StateIndex::LinearAcceleration::Begin</ref>()<sp/>+<sp/>i]<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="524"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>initialized_states[<ref refid="structkinematic__arbiter_1_1core_1_1StateIndex_1_1AngularAcceleration_1aba70ff56c29cff8b0cd60ddd365d093f" kindref="member">StateIndex::AngularAcceleration::Begin</ref>()<sp/>+<sp/>i]<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="525"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="526"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="527"><highlight class="normal"></highlight></codeline>
<codeline lineno="528"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>initialized_states;</highlight></codeline>
<codeline lineno="529"><highlight class="normal">}</highlight></codeline>
<codeline lineno="530"><highlight class="normal"></highlight></codeline>
<codeline lineno="531"><highlight class="normal">}<sp/></highlight><highlight class="comment">//<sp/>namespace<sp/>sensors</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="532"><highlight class="normal">}<sp/></highlight><highlight class="comment">//<sp/>namespace<sp/>kinematic_arbiter</highlight><highlight class="normal"></highlight></codeline>
    </programlisting>
    <location file="/home/spencer/ros2workspace/src/kinematic_arbiter/src/sensors/imu_sensor_model.cpp"/>
  </compounddef>
</doxygen>
